# 2025/08/11 agenda

# やったことメモ
## packageをtaskEditではなく、task.edit と task.createに切り分けた
routineEditやroutineCreateもこうあるべき
## taskEditのuiStateの記述
taskCreateのuiStateの記述も同時にやった
RoutineEditUiStateでは画面全体をLoadedValueにしていたが、大事なのはTaskがLoadedか否か、という部分だけだと感じた　　
TaskのUiState自体はただのdata classにして、レポジトリから取得するプロパティをsealed interfaceで定義することにした  
routineEditもこうあるべきだと思う

## 画面遷移時の引数の扱いについての検討
RoutineEdit画面では、画面遷移時に渡す引数routineIdをScreenの引数として渡していた。
しかしこれでは、viewmodelの初期化時にroutineIdの値が存在することをコンパイラに保証できない。
RoutineEditでは、遷移前画面から受け取った引数routineIdを使うとき以下のようなコードで実装していた  
```kotlin:routineEditScreen.kt
@Composable
fun RoutineEditScreen(
    routineId: Long,
    navHostController: NavHostController,
    viewModel: RoutineEditViewModel = hiltViewModel(),
) {
    LaunchedEffect(Unit) {
        viewModel.fetch(routineId)
    }
```

```kotlin:routineEditViewmodel.kt
fun onRoutineTitleChange(title: String) {
            val state = uiState.value
            if (state !is RoutineEditUiState.Done) return
            viewModelScope.launch {
                routineRepository.updateRoutine(state.routine.copy(name = title))
            }
        }
```

上記のコードでは、2つの問題点がある  
1つは、RoutineUiStateのサブタイプをいちいちチェックしなければならないこと 。 
本来、onRoutineTitleChangeが呼ばれるようなUI状態では確定でuiState.Doneのはずである。実際書いていて気持ち悪かった。 
TaskCreateやTaskEditでも同様の問題が発生しているが、これは現時点ではどうすればそのことをコンパイラに保証できるのかわからず、Done以外だったら何もしない、という実装で不具合が
発生する想像もつかなかったので、一旦放置している。たぶん、viewmodel側の関数の引数にドメインモデルを要求することで回避できそう。

もう一つの問題は、Screen側が持っているval routineIdのライフサイクルがViewModelと異なること。
routineEdit画面の実装時は、この問題に気づいていなかった。
ただ、Screenが持つroutineId、ViewModelが持つドメインモデルのもつroutineIdと、二つの情報源が存在しており、これはSSOTに反する。よくない。  
viewModelだけがroutineIdを持つべきであった。 
問題であることに気づけていなかった要因は、Screen側が持っているroutineIdを使ってfetchした後はRoutineのドメインモデルがroutineIdを持っているため、更新なども問題なく行えたためである。  
TaskCreateにおいては、引数で受け取ったparentRoutineIdはドメインモデルに格納されないのにも関わらず、更新時にデータ層へ渡す必要のある値であるために、この問題に気づいた。

Taskの更新をするためにはRoutineRepositoryにparentRoutineIdを渡す必要があるため、TaskEditViewModelはparentRoutineIdを持たねばならない。
parentRoutineIdをどう持つべきか.

以下の選択肢がある。
1. Taskのドメインモデルに含ませる
2. TaskEditViewModelのプロパティで保存する
3. TaskEditUiStateに含ませる
4. 1~3を状態によって遷移させる

現状では、コード変更量の少なさから2を採用している。しかし、1や4も検討する価値がありそう。
いろいろ考えたけど、ここにリソースを割くより次の工程に進めたほうが生産性が高そうなので思考を止めた。

## savedStateHandleの利用
遷移時に渡す引数をhiltViewmodelが作られる段階でviewmodelのライフサイクルに紐づけることで、UiStateの初期化時に遷移前画面から受け取った引数を使うことが出来る。
。具体的には、savedStateHandleを用いた。

## 
