# 2025/08/11 agenda

# やったことメモ
## packageをtaskEditではなく、task.edit と task.createに切り分けた
routineEditやroutineCreateもこうあるべき  
単語ごとにpackage名を区切る、の意識
RESTFULと近い考え方
- リソースの名前をpath名として扱う文化
## taskEditのuiStateの記述
taskCreateのuiStateの記述も同時にやった
RoutineEditUiStateでは画面全体をLoadedValueにしていたが、大事なのはTaskがLoadedか否か、という部分だけだと感じた　　
TaskのUiState自体はただのdata classにして、レポジトリから取得するプロパティをsealed interfaceで定義することにした  
routineEditもこうあるべきだと思う
インターン先のコードでは、複数のプロパティが全てLoadedかどうか、を判断する関数がuiStateに生えていた記憶
いまは必要ない。最低限のものを提供すればいい

## 画面遷移時の引数の扱いについての検討
RoutineEdit画面では、画面遷移時に渡す引数routineIdをScreenの引数として渡していた。
しかしこれでは、viewmodelの初期化時にroutineIdの値が存在することをコンパイラに保証できない。
RoutineEditでは、遷移前画面から受け取った引数routineIdを使うとき以下のようなコードで実装していた  

compose側
```kotlin:routineEditScreen.kt
@Composable
fun RoutineEditScreen(
    routineId: Long,
    navHostController: NavHostController,
    viewModel: RoutineEditViewModel = hiltViewModel(),
) {
    LaunchedEffect(Unit) {
        viewModel.fetch(routineId)
    }
```

viewmodel側
```kotlin:routineEditViewmodel.kt
fun onRoutineTitleChange(title: String) {
            val state = uiState.value
            if (state !is RoutineEditUiState.Done) return
            viewModelScope.launch {
                routineRepository.updateRoutine(state.routine.copy(name = title))
            }
        }
```

上記のコードでは、2つの関心事がある  
1つは、**uiStateのプロパティをRoutineUiStateのサブタイプをいちいちチェックしなければならない**こと 。 
本来、onRoutineTitleChangeが呼ばれるようなUI状態では確定でuiState.Doneのはず。
TaskCreateやTaskEditでは、**viewmodel側の関数の引数にドメインモデルを要求することで回避**した。

もう1つは、良くない点なのかはまだ確信を持てていないが、ScreenがroutineIdを要求しているところ。  
NavGraphでbackStackEntry.toRouteにアクセスして渡している。
```kotlin
composable<Route.RoutineEdit> {
                backStackEntry ->
            RoutineEditScreen(
                navHostController = navController,
                routineId = backStackEntry.toRoute<Route.RoutineEdit>().routineId,
            )
        }
```
これは、ViewModel側でsavedStateHandle.toRouteからアクセスも出来るはず
後者がちゃんと動くならそちらのほうがいいかも。
 - 小さく実験するべきだったかも

routineIdってUI要素じゃない&viewmodelが欲しがってる値なので、
ライフサイクルがroutineIdに近いsavedStateHandleのほうが納得感のあるコードな気がする


Taskの更新をするためにはRoutineRepositoryにparentRoutineIdを渡す必要があるため、TaskEditViewModelはparentRoutineIdを持たねばならない。
parentRoutineIdをどう持つべきか.

以下の選択肢がある。
1. Taskのドメインモデルに含ませる
2. TaskEditViewModelのプロパティで保存する
3. TaskEditUiStateに含ませる
4. 1~3を状態によって遷移させる

現状では、コード変更量の少なさから2を採用している。uiに関連するStateではないし、Taskのドメインモデルにnullableな値を含ませたくなかったから、というのが現時点での理屈。  
4が必要なほどの複雑性はないと判断。

## savedStateHandleの利用
遷移時に渡す引数をhiltViewmodelが作られる段階でviewmodelのライフサイクルに紐づけることで、UiStateの初期化時に遷移前画面から受け取った引数を使うことが出来る。
。具体的には、savedStateHandleを用いた。それまでのコードでは、routineIdがtaskCreate画面において確定している事実をコンパイラに伝えられず
不必要なガード節が発生していたが、これを削除できた。

## taskEdit ViewModelの作成
task Createとほとんど同じコード。
共通化したいが、できていない。init時にfetchするかcreateするかの違いがあるだけ。
**画面遷移時の引数にisNewを渡して分岐**するのはどうだろうか？
- ドメインモデルの変更などに強くなる
- 現状のdbアクセスの仕様
  - 画面に移行した段階でcreateされる


## やること
TaskCreateScreenの記述
TaskのドメインモデルにparentRoutineIdを持たせ、routineIdのみの状態から新しいインスタンスを作れるようにする
routineEditのPreviewでタスクのドメインを作っているが、IntRange型をつくってforEachなどを呼び出し繰り返しを避けるのが良さそう
Composableはなるべく既存の提供されているものを使う
- TopAppBarは使える範囲でTopAppBarを使いましょう(Material3のsubtitleを使うのも良さそう)
RoutineとTaskにおいて、EditとCreateを共通化する。
- 共通部分の命名はTaskDetailとかが良いかも
- 将来的にはread onlyな画面とかが生えるかも